GlobalDeclarations
{
var {:propertyMap} validFree : [int] bool;
//this is not being expanded
function {:inline true} isValid(p : int, m : [int]bool) returns(bool) {m[p] || p == 0}
function {:ReachableStates} NonNULL(bool) : bool;
var freedp: int; //aliases every freed pointer
var freedNondet: bool;
procedure  freedNondetFn() returns (r:bool);
function {:inline} {:aliasingQuery} {:mkUniqueFn} aliasesWithFreed(p:int, q:int) returns (bool) {true}
}


TemplateVariables
{
var p : int;
procedure {:#AnyArguments} anyProc({:pointer} q : int) returns( {:#AnyParameters} r: int);
}


//Check every dereference is that of a allocated pointer
CmdRule
{
  assume {:nonnull} p != NULL;
}
-->
{
  #this;
  //assert isValid(p, validFree);
  assert (!aliasesWithFreed(p, freedp) || validFree[p] || p == 0); //the inlined function is not expanded
}

//Any parameter should be allocated
CmdRule
{
call anyProc(p);
}
-->
{
//assert isValid(p, validFree);
assert (!aliasesWithFreed(p, freedp) || validFree[p] || p == 0); //the inlined function is not expanded
#this;
}

//Any stub *[fF]ree* is considered a free
ProcedureRule
{
procedure {:#NameMatches "[fF]ree"} {:#NoImplementation} builtin_free({:pointer} p1 : int);
}
-->
{
    validFree[p1] := if (p1 == 0) then validFree[p1] else false;
    call freedNondet := freedNondetFn();
    freedp := if (freedNondetFn) then p1 else freedp;
}

