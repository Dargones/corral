var l: int;

var x: int;

procedure corral_atomic_begin();



procedure corral_atomic_end();



procedure corral_getThreadID() returns (x: int);



procedure corral_yield(x: bool);



function CHThreadId() : int;

function {:existential true} Assert() : bool;

procedure {:single_instance} {:thread_entry} {:thread_num "main"} {:original_proc_name "main"} {:yields} {:entrypoint} main({:linear "Tid"} tid_linear_guy_in: int, InAtomicBlock_in: bool);
  free requires tid_linear_guy_in != 0;
  free requires !InAtomicBlock_in;
  modifies l, x;

procedure Allocate() returns ({:linear "Tid"} xls: int);
ensures xls != 0;

implementation {:entrypoint} main(tid_linear_guy_in: int, InAtomicBlock_in: bool)
{
  var val: int;
  var {:linear "Tid"} tid_linear_guy_out: int;
  var {:linear "Tid"} tid_linear_guy_child: int;
  var InAtomicBlock_out: bool;

  addvars_start_4:
    assume InAtomicBlock_out <==> InAtomicBlock_in;
    goto addvars_start_0;

  addvars_start_0:
    assume tid_linear_guy_out == tid_linear_guy_in;
    goto anon0;

  anon0:
    goto anon2_LoopHead;

  anon2_LoopHead:
    goto anon2_LoopDone, anon2_LoopBody;

  anon2_LoopBody:
    havoc val;
    goto nlabel0, nlabel1;

  nlabel0:
    assume !InAtomicBlock_out;
    yield;
    goto nlabel1;

  nlabel1:
    call tid_linear_guy_child := Allocate() ;
    async call corralThread0foo(val, tid_linear_guy_child, InAtomicBlock_out);
    goto anon2_LoopHead;

  anon2_LoopDone:
    return;
}



procedure {:thread_num "foo"} {:original_proc_name "acquire"} {:yields} corralThread0acquire({:linear "Tid"} tid_linear_guy_in: int, InAtomicBlock_in: bool) returns ({:linear "Tid"} tid_linear_guy_out: int, InAtomicBlock_out: bool);
  free requires tid_linear_guy_in != 0;
  modifies l;
  ensures l == tid_linear_guy_out && l != 0;
  free ensures tid_linear_guy_in == tid_linear_guy_in;



implementation corralThread0acquire(tid_linear_guy_in: int, InAtomicBlock_in: bool) returns (tid_linear_guy_out: int, InAtomicBlock_out: bool)
{
  var {:linear "Tid"} tid_linear_guy_child: int;

  addvars_start_5:
    assume InAtomicBlock_out <==> InAtomicBlock_in;
    goto addvars_start_1;

  addvars_start_1:
    tid_linear_guy_out := tid_linear_guy_in;
    goto anon0;

  anon0:
    goto nlabel2, nlabel3;

  nlabel2:
    assume !InAtomicBlock_out;
    yield;
    goto nlabel3;

  nlabel3:
    InAtomicBlock_out := true;
    goto nlabel4, nlabel5;

  nlabel4:
    assume !InAtomicBlock_out;
    yield;
    goto nlabel5;

  nlabel5:
    assume l == 0;
    goto nlabel6, nlabel7;

  nlabel6:
    assume !InAtomicBlock_out;
    yield;
    goto nlabel7;

  nlabel7:
    l := tid_linear_guy_out;
    InAtomicBlock_out := false;
    return;
}



procedure {:thread_num "foo"} {:original_proc_name "release"} {:yields} corralThread0release({:linear "Tid"} tid_linear_guy_in: int, InAtomicBlock_in: bool) returns ({:linear "Tid"} tid_linear_guy_out: int, InAtomicBlock_out: bool);
  requires l == tid_linear_guy_in && l != 0;
  free requires tid_linear_guy_in != 0;
  modifies l;
  free ensures tid_linear_guy_in == tid_linear_guy_in;



implementation corralThread0release(tid_linear_guy_in: int, InAtomicBlock_in: bool) returns (tid_linear_guy_out: int, InAtomicBlock_out: bool)
{
  var {:linear "Tid"} tid_linear_guy_child: int;

  addvars_start_6:
    assume InAtomicBlock_out <==> InAtomicBlock_in;
    goto addvars_start_2;

  addvars_start_2:
    assume tid_linear_guy_out == tid_linear_guy_in;
    goto anon0;

  anon0:
    goto nlabel8, nlabel9;

  nlabel8:
    assume !InAtomicBlock_out;
    yield;
    assert l == tid_linear_guy_out && l != 0;
    goto nlabel9;

  nlabel9:
    InAtomicBlock_out := true;
    goto nlabel10, nlabel11;

  nlabel10:
    assume !InAtomicBlock_out;
    yield;
    goto nlabel11;

  nlabel11:
    l := 0;
    InAtomicBlock_out := false;
    return;
}



procedure {:single_instance} {:thread_entry} {:thread_num "foo"} {:original_proc_name "foo"} {:stable} {:yields} corralThread0foo(val: int, {:linear "Tid"} tid_linear_guy_in: int, InAtomicBlock_in: bool);
  free requires tid_linear_guy_in != 0;
  free requires !InAtomicBlock_in;
  modifies l, x;



implementation corralThread0foo(val: int, tid_linear_guy_in: int, InAtomicBlock_in: bool)
{
  var {:linear "Tid"} tid_linear_guy_out: int;
  var {:linear "Tid"} tid_linear_guy_child: int;
  var InAtomicBlock_out: bool;

  addvars_start_7:
    assume InAtomicBlock_out <==> InAtomicBlock_in;
    goto addvars_start_3;

  addvars_start_3:
    tid_linear_guy_out := tid_linear_guy_in;
    goto anon0;

  anon0:
    call tid_linear_guy_out, InAtomicBlock_out := corralThread0acquire(tid_linear_guy_out, InAtomicBlock_out);
    goto nlabel12, nlabel13;

  nlabel12:
    assume !InAtomicBlock_out;
    yield;
    assert l == tid_linear_guy_out && l != 0;
    goto nlabel13;

  nlabel13:
    x := val;
    goto nlabel14, nlabel15;

  nlabel14:
    assume !InAtomicBlock_out;
    yield;
    assert Assert() || (l == tid_linear_guy_out && l != 0 && x == val);
    goto nlabel15;

  nlabel15:
    call tid_linear_guy_out, InAtomicBlock_out := corralThread0release(tid_linear_guy_out, InAtomicBlock_out);
    return;
}


